{
  "version": 3,
  "sources": ["../../src/inputmask/style/InputMaskStyle.js", "../../src/inputmask/BaseInputMask.vue", "../../src/inputmask/InputMask.vue", "../../src/inputmask/InputMask.vue?vue&type=template&id=d160eb72&lang.js"],
  "sourcesContent": ["import BaseStyle from '@primevue/core/base/style';\n\nconst classes = {\n    root: ({ instance }) => [\n        'p-inputmask',\n        {\n            'p-filled': instance.$filled\n        }\n    ]\n};\n\nexport default BaseStyle.extend({\n    name: 'inputmask',\n    classes\n});\n", "<script>\nimport BaseInput from '@primevue/core/baseinput';\nimport InputMaskStyle from 'primevue/inputmask/style';\n\nexport default {\n    name: 'BaseInputMask',\n    extends: BaseInput,\n    props: {\n        slotChar: {\n            type: String,\n            default: '_'\n        },\n        id: {\n            type: String,\n            default: null\n        },\n        class: {\n            type: [String, Object],\n            default: null\n        },\n        mask: {\n            type: String,\n            default: null\n        },\n        placeholder: {\n            type: String,\n            default: null\n        },\n        autoClear: {\n            type: Boolean,\n            default: true\n        },\n        unmask: {\n            type: Boolean,\n            default: false\n        },\n        readonly: {\n            type: Boolean,\n            default: false\n        }\n    },\n    style: InputMaskStyle,\n    provide() {\n        return {\n            $pcInputMask: this,\n            $parentInstance: this\n        };\n    }\n};\n</script>\n", "<template>\n    <InputText\n        :id=\"id\"\n        :value=\"currentVal\"\n        :class=\"inputClass\"\n        :readonly=\"readonly\"\n        :disabled=\"disabled\"\n        :invalid=\"invalid\"\n        :size=\"size\"\n        :name=\"name\"\n        :variant=\"variant\"\n        :placeholder=\"placeholder\"\n        :fluid=\"$fluid\"\n        :unstyled=\"unstyled\"\n        @input=\"onInput\"\n        @compositionend=\"onInput\"\n        @focus=\"onFocus\"\n        @blur=\"onBlur\"\n        @keydown=\"onKeyDown\"\n        @keypress=\"onKeyPress\"\n        @paste=\"onPaste\"\n        :pt=\"rootPTOptions\"\n    />\n</template>\n\n<script>\nimport { getUserAgent } from '@primeuix/utils/dom';\nimport InputText from 'primevue/inputtext';\nimport { mergeProps } from 'vue';\nimport BaseInputMask from './BaseInputMask.vue';\n\nexport default {\n    name: 'InputMask',\n    extends: BaseInputMask,\n    inheritAttrs: false,\n    emits: ['focus', 'blur', 'keydown', 'complete', 'keypress', 'paste'],\n    inject: {\n        $pcFluid: { default: null }\n    },\n    data() {\n        return {\n            currentVal: ''\n        };\n    },\n    watch: {\n        mask(newMask, oldMask) {\n            if (oldMask !== newMask) {\n                this.initMask();\n            }\n        }\n    },\n    mounted() {\n        this.initMask();\n    },\n    updated() {\n        if (this.isValueUpdated()) {\n            this.updateValue();\n        }\n    },\n    methods: {\n        onInput(event) {\n            // Check if the event is part of a text composition process (e.g., for Asian languages).\n            // If event.isComposing is true, it means the user is still composing text and the input is not finalized.\n            if (!event.isComposing) {\n                if (this.androidChrome) this.handleAndroidInput(event);\n                else this.handleInputChange(event);\n\n                this.updateModelValue(event.target.value);\n            }\n        },\n        onFocus(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            this.focus = true;\n\n            clearTimeout(this.caretTimeoutId);\n            let pos;\n\n            this.focusText = this.$el.value;\n\n            pos = this.checkVal();\n\n            this.caretTimeoutId = setTimeout(() => {\n                if (this.$el !== document.activeElement) {\n                    return;\n                }\n\n                this.writeBuffer();\n\n                if (pos === this.mask.replace('?', '').length) {\n                    this.caret(0, pos);\n                } else {\n                    this.caret(pos);\n                }\n            }, 10);\n\n            this.$emit('focus', event);\n        },\n        onBlur(event) {\n            this.focus = false;\n            this.checkVal();\n            this.updateModelValue(event.target.value);\n\n            if (this.$el.value !== this.focusText) {\n                let e = document.createEvent('HTMLEvents');\n\n                e.initEvent('change', true, false);\n                this.$el.dispatchEvent(e);\n            }\n\n            this.$emit('blur', event);\n            this.formField.onBlur?.(event);\n        },\n        onKeyDown(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            let k = event.code,\n                pos,\n                begin,\n                end;\n            let iPhone = /iphone/i.test(getUserAgent());\n\n            this.oldVal = this.$el.value;\n\n            //backspace, delete, and escape get special treatment\n            if (k === 'Backspace' || k === 'Delete' || (iPhone && k === 'Escape')) {\n                pos = this.caret();\n                begin = pos.begin;\n                end = pos.end;\n\n                if (end - begin === 0) {\n                    begin = k !== 'Delete' ? this.seekPrev(begin) : (end = this.seekNext(begin - 1));\n                    end = k === 'Delete' ? this.seekNext(end) : end;\n                }\n\n                this.clearBuffer(begin, end);\n                this.shiftL(begin, end - 1);\n                this.updateModelValue(event.target.value);\n\n                event.preventDefault();\n            } else if (k === 'Enter') {\n                // enter\n                this.$el.blur();\n                this.updateModelValue(event.target.value);\n            } else if (k === 'Escape') {\n                // escape\n                this.$el.value = this.focusText;\n                this.caret(0, this.checkVal());\n                this.updateModelValue(event.target.value);\n                event.preventDefault();\n            }\n\n            this.$emit('keydown', event);\n        },\n        onKeyPress(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            var k = event.code,\n                pos = this.caret(),\n                p,\n                c,\n                next,\n                completed;\n\n            if (event.ctrlKey || event.altKey || event.metaKey || event.shiftKey || event.key === 'CapsLock' || event.key === 'Escape' || event.key === 'Tab') {\n                //Ignore\n                return;\n            } else if (k && k !== 'Enter') {\n                if (pos.end - pos.begin !== 0) {\n                    this.clearBuffer(pos.begin, pos.end);\n                    this.shiftL(pos.begin, pos.end - 1);\n                }\n\n                p = this.seekNext(pos.begin - 1);\n\n                if (p < this.len) {\n                    c = event.key;\n\n                    if (this.tests[p].test(c)) {\n                        this.shiftR(p);\n\n                        this.buffer[p] = c;\n                        this.writeBuffer();\n                        next = this.seekNext(p);\n\n                        if (/android/i.test(getUserAgent())) {\n                            //Path for CSP Violation on FireFox OS 1.1\n                            let proxy = () => {\n                                this.caret(next);\n                            };\n\n                            setTimeout(proxy, 0);\n                        } else {\n                            this.caret(next);\n                        }\n\n                        if (pos.begin <= this.lastRequiredNonMaskPos) {\n                            completed = this.isCompleted();\n                        }\n                    }\n                }\n\n                event.preventDefault();\n            }\n\n            this.updateModelValue(event.target.value);\n\n            if (completed) {\n                this.$emit('complete', event);\n            }\n\n            this.$emit('keypress', event);\n        },\n        onPaste(event) {\n            this.handleInputChange(event);\n\n            this.$emit('paste', event);\n        },\n        caret(first, last) {\n            let range, begin, end;\n\n            if (!this.$el.offsetParent || this.$el !== document.activeElement) {\n                return;\n            }\n\n            if (typeof first === 'number') {\n                begin = first;\n                end = typeof last === 'number' ? last : begin;\n\n                if (this.$el.setSelectionRange) {\n                    this.$el.setSelectionRange(begin, end);\n                } else if (this.$el['createTextRange']) {\n                    range = this.$el['createTextRange']();\n                    range.collapse(true);\n                    range.moveEnd('character', end);\n                    range.moveStart('character', begin);\n                    range.select();\n                }\n            } else {\n                if (this.$el.setSelectionRange) {\n                    begin = this.$el.selectionStart;\n                    end = this.$el.selectionEnd;\n                } else if (document['selection'] && document['selection'].createRange) {\n                    range = document['selection'].createRange();\n                    begin = 0 - range.duplicate().moveStart('character', -100000);\n                    end = begin + range.text.length;\n                }\n\n                return { begin: begin, end: end };\n            }\n        },\n        isCompleted() {\n            for (let i = this.firstNonMaskPos; i <= this.lastRequiredNonMaskPos; i++) {\n                if (this.tests[i] && this.buffer[i] === this.getPlaceholder(i)) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n        getPlaceholder(i) {\n            if (i < this.slotChar.length) {\n                return this.slotChar.charAt(i);\n            }\n\n            return this.slotChar.charAt(0);\n        },\n        seekNext(pos) {\n            while (++pos < this.len && !this.tests[pos]);\n\n            return pos;\n        },\n        seekPrev(pos) {\n            while (--pos >= 0 && !this.tests[pos]);\n\n            return pos;\n        },\n        shiftL(begin, end) {\n            let i, j;\n\n            if (begin < 0) {\n                return;\n            }\n\n            for (i = begin, j = this.seekNext(end); i < this.len; i++) {\n                if (this.tests[i]) {\n                    if (j < this.len && this.tests[i].test(this.buffer[j])) {\n                        this.buffer[i] = this.buffer[j];\n                        this.buffer[j] = this.getPlaceholder(j);\n                    } else {\n                        break;\n                    }\n\n                    j = this.seekNext(j);\n                }\n            }\n\n            this.writeBuffer();\n            this.caret(Math.max(this.firstNonMaskPos, begin));\n        },\n        shiftR(pos) {\n            let i, c, j, t;\n\n            for (i = pos, c = this.getPlaceholder(pos); i < this.len; i++) {\n                if (this.tests[i]) {\n                    j = this.seekNext(i);\n                    t = this.buffer[i];\n                    this.buffer[i] = c;\n\n                    if (j < this.len && this.tests[j].test(t)) {\n                        c = t;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        },\n        handleAndroidInput(event) {\n            var curVal = this.$el.value;\n            var pos = this.caret();\n\n            if (this.oldVal && this.oldVal.length && this.oldVal.length > curVal.length) {\n                // a deletion or backspace happened\n                this.checkVal(true);\n                while (pos.begin > 0 && !this.tests[pos.begin - 1]) pos.begin--;\n\n                if (pos.begin === 0) {\n                    while (pos.begin < this.firstNonMaskPos && !this.tests[pos.begin]) pos.begin++;\n                }\n\n                this.caret(pos.begin, pos.begin);\n            } else {\n                this.checkVal(true);\n                while (pos.begin < this.len && !this.tests[pos.begin]) pos.begin++;\n\n                this.caret(pos.begin, pos.begin);\n            }\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        clearBuffer(start, end) {\n            let i;\n\n            for (i = start; i < end && i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n                }\n            }\n        },\n        writeBuffer() {\n            this.$el.value = this.buffer.join('');\n        },\n        checkVal(allow) {\n            this.isValueChecked = true;\n            //try to place characters where they belong\n            let test = this.$el.value,\n                lastMatch = -1,\n                i,\n                c,\n                pos;\n\n            for (i = 0, pos = 0; i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n\n                    while (pos++ < test.length) {\n                        c = test.charAt(pos - 1);\n\n                        if (this.tests[i].test(c)) {\n                            this.buffer[i] = c;\n                            lastMatch = i;\n                            break;\n                        }\n                    }\n\n                    if (pos > test.length) {\n                        this.clearBuffer(i + 1, this.len);\n                        break;\n                    }\n                } else {\n                    if (this.buffer[i] === test.charAt(pos)) {\n                        pos++;\n                    }\n\n                    if (i < this.partialPosition) {\n                        lastMatch = i;\n                    }\n                }\n            }\n\n            if (allow) {\n                this.writeBuffer();\n            } else if (lastMatch + 1 < this.partialPosition) {\n                if (this.autoClear || this.buffer.join('') === this.defaultBuffer) {\n                    // Invalid value. Remove it and replace it with the\n                    // mask, which is the default behavior.\n                    if (this.$el.value) this.$el.value = '';\n                    this.clearBuffer(0, this.len);\n                } else {\n                    // Invalid value, but we opt to show the value to the\n                    // user and allow them to correct their mistake.\n                    this.writeBuffer();\n                }\n            } else {\n                this.writeBuffer();\n                this.$el.value = this.$el.value.substring(0, lastMatch + 1);\n            }\n\n            return this.partialPosition ? i : this.firstNonMaskPos;\n        },\n        handleInputChange(event) {\n            const isPasteEvent = event.type === 'paste';\n\n            if (this.readonly || isPasteEvent) {\n                return;\n            }\n\n            var pos = this.checkVal(true);\n\n            this.caret(pos);\n            this.updateModelValue(event.target.value);\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        getUnmaskedValue() {\n            let unmaskedBuffer = [];\n\n            for (let i = 0; i < this.buffer.length; i++) {\n                let c = this.buffer[i];\n\n                if (this.tests[i] && c !== this.getPlaceholder(i)) {\n                    unmaskedBuffer.push(c);\n                }\n            }\n\n            return unmaskedBuffer.join('');\n        },\n\n        updateModelValue(value) {\n            const val = this.unmask ? this.getUnmaskedValue() : value;\n\n            this.currentVal = value;\n\n            this.writeValue(this.defaultBuffer !== val ? val : '');\n        },\n        updateValue(updateModel = true) {\n            if (this.$el) {\n                if (this.d_value == null) {\n                    this.$el.value = '';\n                    updateModel && this.updateModelValue('');\n                } else {\n                    this.$el.value = this.d_value;\n                    this.checkVal();\n\n                    setTimeout(() => {\n                        if (this.$el) {\n                            this.writeBuffer();\n                            this.checkVal();\n\n                            if (updateModel) this.updateModelValue(this.$el.value);\n                        }\n                    }, 10);\n                }\n\n                this.focusText = this.$el.value;\n            }\n        },\n        initMask() {\n            this.tests = [];\n            this.partialPosition = this.mask.length;\n            this.len = this.mask.length;\n            this.firstNonMaskPos = null;\n            this.defs = {\n                9: '[0-9]',\n                a: '[A-Za-z]',\n                '*': '[A-Za-z0-9]'\n            };\n\n            let ua = getUserAgent();\n\n            this.androidChrome = /chrome/i.test(ua) && /android/i.test(ua);\n\n            let maskTokens = this.mask.split('');\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c === '?') {\n                    this.len--;\n                    this.partialPosition = i;\n                } else if (this.defs[c]) {\n                    this.tests.push(new RegExp(this.defs[c]));\n\n                    if (this.firstNonMaskPos === null) {\n                        this.firstNonMaskPos = this.tests.length - 1;\n                    }\n\n                    if (i < this.partialPosition) {\n                        this.lastRequiredNonMaskPos = this.tests.length - 1;\n                    }\n                } else {\n                    this.tests.push(null);\n                }\n            }\n\n            this.buffer = [];\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c !== '?') {\n                    if (this.defs[c]) this.buffer.push(this.getPlaceholder(i));\n                    else this.buffer.push(c);\n                }\n            }\n\n            this.defaultBuffer = this.buffer.join('');\n            this.updateValue(false);\n        },\n        isValueUpdated() {\n            return this.unmask ? this.d_value != this.getUnmaskedValue() : this.defaultBuffer !== this.$el.value && this.$el.value !== this.d_value;\n        }\n    },\n    computed: {\n        inputClass() {\n            return [this.cx('root'), this.class];\n        },\n        rootPTOptions() {\n            return {\n                root: mergeProps(this.ptm('pcInputText', this.ptmParams), this.ptmi('root', this.ptmParams))\n            };\n        },\n        ptmParams() {\n            return {\n                context: {\n                    filled: this.$filled\n                }\n            };\n        }\n    },\n    components: {\n        InputText\n    }\n};\n</script>\n", "<template>\n    <InputText\n        :id=\"id\"\n        :value=\"currentVal\"\n        :class=\"inputClass\"\n        :readonly=\"readonly\"\n        :disabled=\"disabled\"\n        :invalid=\"invalid\"\n        :size=\"size\"\n        :name=\"name\"\n        :variant=\"variant\"\n        :placeholder=\"placeholder\"\n        :fluid=\"$fluid\"\n        :unstyled=\"unstyled\"\n        @input=\"onInput\"\n        @compositionend=\"onInput\"\n        @focus=\"onFocus\"\n        @blur=\"onBlur\"\n        @keydown=\"onKeyDown\"\n        @keypress=\"onKeyPress\"\n        @paste=\"onPaste\"\n        :pt=\"rootPTOptions\"\n    />\n</template>\n\n<script>\nimport { getUserAgent } from '@primeuix/utils/dom';\nimport InputText from 'primevue/inputtext';\nimport { mergeProps } from 'vue';\nimport BaseInputMask from './BaseInputMask.vue';\n\nexport default {\n    name: 'InputMask',\n    extends: BaseInputMask,\n    inheritAttrs: false,\n    emits: ['focus', 'blur', 'keydown', 'complete', 'keypress', 'paste'],\n    inject: {\n        $pcFluid: { default: null }\n    },\n    data() {\n        return {\n            currentVal: ''\n        };\n    },\n    watch: {\n        mask(newMask, oldMask) {\n            if (oldMask !== newMask) {\n                this.initMask();\n            }\n        }\n    },\n    mounted() {\n        this.initMask();\n    },\n    updated() {\n        if (this.isValueUpdated()) {\n            this.updateValue();\n        }\n    },\n    methods: {\n        onInput(event) {\n            // Check if the event is part of a text composition process (e.g., for Asian languages).\n            // If event.isComposing is true, it means the user is still composing text and the input is not finalized.\n            if (!event.isComposing) {\n                if (this.androidChrome) this.handleAndroidInput(event);\n                else this.handleInputChange(event);\n\n                this.updateModelValue(event.target.value);\n            }\n        },\n        onFocus(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            this.focus = true;\n\n            clearTimeout(this.caretTimeoutId);\n            let pos;\n\n            this.focusText = this.$el.value;\n\n            pos = this.checkVal();\n\n            this.caretTimeoutId = setTimeout(() => {\n                if (this.$el !== document.activeElement) {\n                    return;\n                }\n\n                this.writeBuffer();\n\n                if (pos === this.mask.replace('?', '').length) {\n                    this.caret(0, pos);\n                } else {\n                    this.caret(pos);\n                }\n            }, 10);\n\n            this.$emit('focus', event);\n        },\n        onBlur(event) {\n            this.focus = false;\n            this.checkVal();\n            this.updateModelValue(event.target.value);\n\n            if (this.$el.value !== this.focusText) {\n                let e = document.createEvent('HTMLEvents');\n\n                e.initEvent('change', true, false);\n                this.$el.dispatchEvent(e);\n            }\n\n            this.$emit('blur', event);\n            this.formField.onBlur?.(event);\n        },\n        onKeyDown(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            let k = event.code,\n                pos,\n                begin,\n                end;\n            let iPhone = /iphone/i.test(getUserAgent());\n\n            this.oldVal = this.$el.value;\n\n            //backspace, delete, and escape get special treatment\n            if (k === 'Backspace' || k === 'Delete' || (iPhone && k === 'Escape')) {\n                pos = this.caret();\n                begin = pos.begin;\n                end = pos.end;\n\n                if (end - begin === 0) {\n                    begin = k !== 'Delete' ? this.seekPrev(begin) : (end = this.seekNext(begin - 1));\n                    end = k === 'Delete' ? this.seekNext(end) : end;\n                }\n\n                this.clearBuffer(begin, end);\n                this.shiftL(begin, end - 1);\n                this.updateModelValue(event.target.value);\n\n                event.preventDefault();\n            } else if (k === 'Enter') {\n                // enter\n                this.$el.blur();\n                this.updateModelValue(event.target.value);\n            } else if (k === 'Escape') {\n                // escape\n                this.$el.value = this.focusText;\n                this.caret(0, this.checkVal());\n                this.updateModelValue(event.target.value);\n                event.preventDefault();\n            }\n\n            this.$emit('keydown', event);\n        },\n        onKeyPress(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            var k = event.code,\n                pos = this.caret(),\n                p,\n                c,\n                next,\n                completed;\n\n            if (event.ctrlKey || event.altKey || event.metaKey || event.shiftKey || event.key === 'CapsLock' || event.key === 'Escape' || event.key === 'Tab') {\n                //Ignore\n                return;\n            } else if (k && k !== 'Enter') {\n                if (pos.end - pos.begin !== 0) {\n                    this.clearBuffer(pos.begin, pos.end);\n                    this.shiftL(pos.begin, pos.end - 1);\n                }\n\n                p = this.seekNext(pos.begin - 1);\n\n                if (p < this.len) {\n                    c = event.key;\n\n                    if (this.tests[p].test(c)) {\n                        this.shiftR(p);\n\n                        this.buffer[p] = c;\n                        this.writeBuffer();\n                        next = this.seekNext(p);\n\n                        if (/android/i.test(getUserAgent())) {\n                            //Path for CSP Violation on FireFox OS 1.1\n                            let proxy = () => {\n                                this.caret(next);\n                            };\n\n                            setTimeout(proxy, 0);\n                        } else {\n                            this.caret(next);\n                        }\n\n                        if (pos.begin <= this.lastRequiredNonMaskPos) {\n                            completed = this.isCompleted();\n                        }\n                    }\n                }\n\n                event.preventDefault();\n            }\n\n            this.updateModelValue(event.target.value);\n\n            if (completed) {\n                this.$emit('complete', event);\n            }\n\n            this.$emit('keypress', event);\n        },\n        onPaste(event) {\n            this.handleInputChange(event);\n\n            this.$emit('paste', event);\n        },\n        caret(first, last) {\n            let range, begin, end;\n\n            if (!this.$el.offsetParent || this.$el !== document.activeElement) {\n                return;\n            }\n\n            if (typeof first === 'number') {\n                begin = first;\n                end = typeof last === 'number' ? last : begin;\n\n                if (this.$el.setSelectionRange) {\n                    this.$el.setSelectionRange(begin, end);\n                } else if (this.$el['createTextRange']) {\n                    range = this.$el['createTextRange']();\n                    range.collapse(true);\n                    range.moveEnd('character', end);\n                    range.moveStart('character', begin);\n                    range.select();\n                }\n            } else {\n                if (this.$el.setSelectionRange) {\n                    begin = this.$el.selectionStart;\n                    end = this.$el.selectionEnd;\n                } else if (document['selection'] && document['selection'].createRange) {\n                    range = document['selection'].createRange();\n                    begin = 0 - range.duplicate().moveStart('character', -100000);\n                    end = begin + range.text.length;\n                }\n\n                return { begin: begin, end: end };\n            }\n        },\n        isCompleted() {\n            for (let i = this.firstNonMaskPos; i <= this.lastRequiredNonMaskPos; i++) {\n                if (this.tests[i] && this.buffer[i] === this.getPlaceholder(i)) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n        getPlaceholder(i) {\n            if (i < this.slotChar.length) {\n                return this.slotChar.charAt(i);\n            }\n\n            return this.slotChar.charAt(0);\n        },\n        seekNext(pos) {\n            while (++pos < this.len && !this.tests[pos]);\n\n            return pos;\n        },\n        seekPrev(pos) {\n            while (--pos >= 0 && !this.tests[pos]);\n\n            return pos;\n        },\n        shiftL(begin, end) {\n            let i, j;\n\n            if (begin < 0) {\n                return;\n            }\n\n            for (i = begin, j = this.seekNext(end); i < this.len; i++) {\n                if (this.tests[i]) {\n                    if (j < this.len && this.tests[i].test(this.buffer[j])) {\n                        this.buffer[i] = this.buffer[j];\n                        this.buffer[j] = this.getPlaceholder(j);\n                    } else {\n                        break;\n                    }\n\n                    j = this.seekNext(j);\n                }\n            }\n\n            this.writeBuffer();\n            this.caret(Math.max(this.firstNonMaskPos, begin));\n        },\n        shiftR(pos) {\n            let i, c, j, t;\n\n            for (i = pos, c = this.getPlaceholder(pos); i < this.len; i++) {\n                if (this.tests[i]) {\n                    j = this.seekNext(i);\n                    t = this.buffer[i];\n                    this.buffer[i] = c;\n\n                    if (j < this.len && this.tests[j].test(t)) {\n                        c = t;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        },\n        handleAndroidInput(event) {\n            var curVal = this.$el.value;\n            var pos = this.caret();\n\n            if (this.oldVal && this.oldVal.length && this.oldVal.length > curVal.length) {\n                // a deletion or backspace happened\n                this.checkVal(true);\n                while (pos.begin > 0 && !this.tests[pos.begin - 1]) pos.begin--;\n\n                if (pos.begin === 0) {\n                    while (pos.begin < this.firstNonMaskPos && !this.tests[pos.begin]) pos.begin++;\n                }\n\n                this.caret(pos.begin, pos.begin);\n            } else {\n                this.checkVal(true);\n                while (pos.begin < this.len && !this.tests[pos.begin]) pos.begin++;\n\n                this.caret(pos.begin, pos.begin);\n            }\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        clearBuffer(start, end) {\n            let i;\n\n            for (i = start; i < end && i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n                }\n            }\n        },\n        writeBuffer() {\n            this.$el.value = this.buffer.join('');\n        },\n        checkVal(allow) {\n            this.isValueChecked = true;\n            //try to place characters where they belong\n            let test = this.$el.value,\n                lastMatch = -1,\n                i,\n                c,\n                pos;\n\n            for (i = 0, pos = 0; i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n\n                    while (pos++ < test.length) {\n                        c = test.charAt(pos - 1);\n\n                        if (this.tests[i].test(c)) {\n                            this.buffer[i] = c;\n                            lastMatch = i;\n                            break;\n                        }\n                    }\n\n                    if (pos > test.length) {\n                        this.clearBuffer(i + 1, this.len);\n                        break;\n                    }\n                } else {\n                    if (this.buffer[i] === test.charAt(pos)) {\n                        pos++;\n                    }\n\n                    if (i < this.partialPosition) {\n                        lastMatch = i;\n                    }\n                }\n            }\n\n            if (allow) {\n                this.writeBuffer();\n            } else if (lastMatch + 1 < this.partialPosition) {\n                if (this.autoClear || this.buffer.join('') === this.defaultBuffer) {\n                    // Invalid value. Remove it and replace it with the\n                    // mask, which is the default behavior.\n                    if (this.$el.value) this.$el.value = '';\n                    this.clearBuffer(0, this.len);\n                } else {\n                    // Invalid value, but we opt to show the value to the\n                    // user and allow them to correct their mistake.\n                    this.writeBuffer();\n                }\n            } else {\n                this.writeBuffer();\n                this.$el.value = this.$el.value.substring(0, lastMatch + 1);\n            }\n\n            return this.partialPosition ? i : this.firstNonMaskPos;\n        },\n        handleInputChange(event) {\n            const isPasteEvent = event.type === 'paste';\n\n            if (this.readonly || isPasteEvent) {\n                return;\n            }\n\n            var pos = this.checkVal(true);\n\n            this.caret(pos);\n            this.updateModelValue(event.target.value);\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        getUnmaskedValue() {\n            let unmaskedBuffer = [];\n\n            for (let i = 0; i < this.buffer.length; i++) {\n                let c = this.buffer[i];\n\n                if (this.tests[i] && c !== this.getPlaceholder(i)) {\n                    unmaskedBuffer.push(c);\n                }\n            }\n\n            return unmaskedBuffer.join('');\n        },\n\n        updateModelValue(value) {\n            const val = this.unmask ? this.getUnmaskedValue() : value;\n\n            this.currentVal = value;\n\n            this.writeValue(this.defaultBuffer !== val ? val : '');\n        },\n        updateValue(updateModel = true) {\n            if (this.$el) {\n                if (this.d_value == null) {\n                    this.$el.value = '';\n                    updateModel && this.updateModelValue('');\n                } else {\n                    this.$el.value = this.d_value;\n                    this.checkVal();\n\n                    setTimeout(() => {\n                        if (this.$el) {\n                            this.writeBuffer();\n                            this.checkVal();\n\n                            if (updateModel) this.updateModelValue(this.$el.value);\n                        }\n                    }, 10);\n                }\n\n                this.focusText = this.$el.value;\n            }\n        },\n        initMask() {\n            this.tests = [];\n            this.partialPosition = this.mask.length;\n            this.len = this.mask.length;\n            this.firstNonMaskPos = null;\n            this.defs = {\n                9: '[0-9]',\n                a: '[A-Za-z]',\n                '*': '[A-Za-z0-9]'\n            };\n\n            let ua = getUserAgent();\n\n            this.androidChrome = /chrome/i.test(ua) && /android/i.test(ua);\n\n            let maskTokens = this.mask.split('');\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c === '?') {\n                    this.len--;\n                    this.partialPosition = i;\n                } else if (this.defs[c]) {\n                    this.tests.push(new RegExp(this.defs[c]));\n\n                    if (this.firstNonMaskPos === null) {\n                        this.firstNonMaskPos = this.tests.length - 1;\n                    }\n\n                    if (i < this.partialPosition) {\n                        this.lastRequiredNonMaskPos = this.tests.length - 1;\n                    }\n                } else {\n                    this.tests.push(null);\n                }\n            }\n\n            this.buffer = [];\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c !== '?') {\n                    if (this.defs[c]) this.buffer.push(this.getPlaceholder(i));\n                    else this.buffer.push(c);\n                }\n            }\n\n            this.defaultBuffer = this.buffer.join('');\n            this.updateValue(false);\n        },\n        isValueUpdated() {\n            return this.unmask ? this.d_value != this.getUnmaskedValue() : this.defaultBuffer !== this.$el.value && this.$el.value !== this.d_value;\n        }\n    },\n    computed: {\n        inputClass() {\n            return [this.cx('root'), this.class];\n        },\n        rootPTOptions() {\n            return {\n                root: mergeProps(this.ptm('pcInputText', this.ptmParams), this.ptmi('root', this.ptmParams))\n            };\n        },\n        ptmParams() {\n            return {\n                context: {\n                    filled: this.$filled\n                }\n            };\n        }\n    },\n    components: {\n        InputText\n    }\n};\n</script>\n"],
  "mappings": "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",
  "names": ["classes", "root", "_ref", "instance", "$filled", "BaseStyle", "extend", "name", "name", "BaseInput", "props", "slotChar", "type", "String", "id", "Object", "mask", "placeholder", "autoClear", "Boolean", "unmask", "readonly", "style", "InputMaskStyle", "provide", "$pcInputMask", "$parentInstance", "script", "BaseInputMask", "inheritAttrs", "emits", "inject", "$pcFluid", "data", "currentVal", "watch", "newMask", "oldMask", "initMask", "mounted", "updated", "isValueUpdated", "updateValue", "methods", "onInput", "event", "isComposing", "androidChrome", "handleAndroidInput", "handleInputChange", "updateModelValue", "target", "value", "onFocus", "_this", "focus", "clearTimeout", "caretTimeoutId", "pos", "focusText", "$el", "checkVal", "setTimeout", "document", "activeElement", "writeBuffer", "replace", "length", "caret", "$emit", "onBlur", "_this$formField$onBlu", "_this$formField", "e", "createEvent", "initEvent", "dispatchEvent", "formField", "call", "onKeyDown", "k", "code", "begin", "end", "iPhone", "test", "getUserAgent", "oldVal", "seekPrev", "seekNext", "clearBuffer", "shiftL", "preventDefault", "blur", "onKeyPress", "_this2", "p", "c", "next", "completed", "ctrlKey", "altKey", "metaKey", "shiftKey", "key", "len", "tests", "shiftR", "buffer", "proxy", "lastRequiredNonMaskPos", "isCompleted", "onPaste", "first", "last", "range", "offsetParent", "setSelectionRange", "collapse", "moveEnd", "moveStart", "select", "selectionStart", "selectionEnd", "createRange", "duplicate", "text", "i", "firstNonMaskPos", "getPlaceholder", "charAt", "j", "Math", "max", "t", "curVal", "start", "join", "allow", "isValueChecked", "lastMatch", "partialPosition", "defaultBuffer", "substring", "isPasteEvent", "getUnmaskedValue", "unmaskedBuffer", "push", "val", "writeValue", "_this3", "updateModel", "arguments", "undefined", "d_value", "defs", "a", "ua", "maskTokens", "split", "RegExp", "computed", "inputClass", "cx", "rootPTOptions", "root", "mergeProps", "ptm", "ptmParams", "ptmi", "context", "filled", "$filled", "components", "InputText", "_createBlock", "_component_InputText", "_ctx", "$data", "$options", "disabled", "invalid", "size", "variant", "fluid", "$fluid", "unstyled", "onCompositionend", "onKeydown", "onKeypress", "pt"]
}
